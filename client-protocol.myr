use std
use "types"
use "util"
use "connection"

// TODO: make trait listener first argument @a instead of @a once
// composite types can implement traits

pkg wl =
	/* display */
	const display_sync: (obj: display# -> callback#)
	const display_getregistry: (obj: display# -> registry#)
	type display_error = struct
		objectid: object#
		code: uint32
		message: byte[:]
	;;
	type display_deleteid = struct
		id: uint32
	;;
	trait display_listener @a =
		display_error: (l: @a#, ev: display_error# -> void)
		display_deleteid: (l: @a#, ev: display_deleteid# -> void)
	;;
	generic display_setlistener: (obj: display#, l: @a::display_listener# -> void)

	/* registry */
	type registry = object
	generic registry_bind: (obj: registry#, name: uint32, interface: byte[:], version: uint32 -> @a#)
	type registry_global = struct
		name: uint32
		interface: byte[:]
		version: uint32
	;;
	type registry_globalremove = struct
		name: uint32
	;;
	trait registry_listener @a =
		registry_global: (l: @a#, ev: registry_global# -> void)
		registry_globalremove: (l: @a#, ev: registry_globalremove# -> void)
	;;
	generic registry_setlistener: (obj: registry#, l: @a::registry_listener# -> void)

	/* callback */
	type callback = object
	type callback_done = struct
		callback_data: uint32
	;;
	trait callback_listener @a =
		callback_done: (l: @a#, ev: callback_done# -> void)
	;;
	generic callback_setlistener: (cb: callback#, l: @a::callback_listener# -> void)

	/* compositor */
	type compositor = object
	const compositor_createsurface: (o: compositor# -> surface#)

	/* surface */
	type surface = object
	const surface_attach: (obj: surface#, buffer: std.option(buffer#), x: int32, y: int32 -> void)
	const surface_damage: (obj: surface#, x: int32, y: int32, width: int32, height: int32 -> void)
	const surface_commit: (obj: surface# -> void)

	/* shm */
	type shm = object
	const Shmformat_xrgb8888: uint32 = 1
	const shm_createpool: (obj: shm#, fd: std.fd, size: int32 -> shmpool#)

	/* shm_pool */
	type shmpool = object
	const shmpool_createbuffer: (obj: shmpool#, offset: int32, width: int32, height: int32, stride: int32, format: uint32 -> buffer#)

	/* buffer */
	type buffer = object

	/* shell */
	type shell = object
	const shell_getshellsurface: (obj: shell#, surface: surface# -> shellsurface#)

	/* shell_surface */
	type shellsurface = object
	const shellsurface_settoplevel: (obj: shellsurface# -> void)
;;

/* display */
const display_sync = {d
	var obj = mkobj(d.obj.conn)
	marshal(&d.conn, &d.obj, 0, [
		`Arguint obj.id,
	][:])
	-> (obj: callback#)
}

const display_getregistry = {d
	var obj = mkobj(d.obj.conn)
	marshal(&d.conn, &d.obj, 1, [
		`Arguint obj.id,
	][:])
	-> (obj: registry#)
}

generic display_setlistener = {dpy, l
	var obj = &dpy.obj

	obj.dispatch = `std.Some std.fndup({op, d
		match op
		| 0:
			var ev
			ev.objectid = std.get(mapget(&obj.conn.objs, get(&d)))
			ev.code = get(&d)
			ev.message = get(&d)
			display_error(l, &ev)
		| 1:
			var ev
			ev.id = get(&d)
			display_deleteid(l, &ev)
		| _:
			std.fatal("unrecognized op\n")
		;;
	})
}

/* registry */
generic registry_bind = {obj, name, interface, version
	var newobj = mkobj(obj.conn)
	marshal(obj.conn, (obj: object#), 0, [
		`Arguint name,
		`Argstr interface,
		`Arguint version,
		`Arguint newobj.id
	][:])
	-> (newobj: @a#)
}

generic registry_setlistener = {obj, l
	obj.dispatch = `std.Some std.fndup({op, d
		match op
		| 0:
			var ev
			ev.name = get(&d)
			ev.interface = getstr(&d)
			ev.version = get(&d)
			registry_global(l, &ev)
		| 1:
			var ev
			ev.name = get(&d)
			registry_globalremove(l, &ev)
		| _:
			std.fatal("unrecognized op\n")
		;;
	})
}

/* callback */
generic callback_setlistener = {r, l
	r.dispatch = `std.Some std.fndup({op, d
		match op
		| 0:
			var ev
			ev.callback_data = get(&d)
			callback_done(l, &ev)
		| _:
			std.fatal("unrecognized op\n")
		;;
	})
}

/* compositor */
const compositor_createsurface = {obj: compositor#
	var newobj = mkobj(obj.conn)
	marshal(obj.conn, (obj: object#), 0, [
		`Arguint newobj.id,
	][:])
	-> (newobj: surface#)
}

/* surface */
const surface_attach = {obj, buffer, x, y
	var id: uint32
	match buffer
	| `std.Some o: id = o.id
	| _: id = 0
	;;
	marshal(obj.conn, (obj: object#), 1, [
		`Arguint id,
		`Argint x,
		`Argint y,
	][:])
}

const surface_damage = {obj, x, y, width, height
	marshal(obj.conn, (obj: object#), 2, [
		`Argint x,
		`Argint y,
		`Argint width,
		`Argint height,
	][:])
}

const surface_commit = {obj
	marshal(obj.conn, (obj: object#), 6, [][:])
}

/* shm */
const shm_createpool = {obj, fd, size
	var newobj = mkobj(obj.conn)
	marshal(obj.conn, (obj: object#), 0, [
		`Arguint newobj.id,
		`Argfd fd,
		`Argint size
	][:])
	-> (newobj: shmpool#)
}

/* shm_pool */
const shmpool_createbuffer = {obj, offset, width, height, stride, format
	var newobj = mkobj(obj.conn)
	marshal(obj.conn, (obj: object#), 0, [
		`Arguint newobj.id,
		`Argint offset,
		`Argint width,
		`Argint height,
		`Argint stride,
		`Arguint format,
	][:])
	-> (newobj: buffer#)
}

/* shell */
const shell_getshellsurface = {obj, surface
	var newobj = mkobj(obj.conn)
	marshal(obj.conn, (obj: object#), 0, [
		`Arguint newobj.id,
		`Arguint surface.id,
	][:])
	-> (newobj: shellsurface#)
}

/* shell_surface */
const shellsurface_settoplevel = {obj
	marshal(obj.conn, (obj: object#), 3, [][:])
}
